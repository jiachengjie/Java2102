4.1 token机制
    1.服务端提供了发生token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去
    获取token,服务器会把token保存到redis中。
    2.然后在调用业务接口请求时，把token携带过去，一般放在请求头部。
    3.服务器判断token是否存在于redis中，存在表示第一次请求，然后删除token，继续执行业务
    4.如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给客户端，这样就保证了业务代码，不被重复执行

    危险性：
    1、先删除token还是后删除token
        如果是后删除令牌，用户点提交订单，连续点两次，第一次提交订单，还没执行完，还没来得及删除令牌，
        第二次的提交订单就进来，这样就出现数据不一致的问题了。

        如果是先删除令牌，一般分布式下，token存redis里，假设用户还是点的很快，连续点了两次提价订单，
        两个请求同时去redis里获取token，同时对比成功，同时删令牌，同时执行业务逻辑，这就会出现一定的
        风险

        因此，如果是先删除令牌，获取redis里的令牌操作，和前端带来的token比较的操作以及删除令牌的操作，
        即：获取，对比，删除 这三个操作必须是原子的，给上个分布式锁
4.2 各种锁机制
     1、数据库悲观锁
        select * from XXX where id=1 for update;
        悲观锁使用时伴随着事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id
        字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来非常麻烦。
     2、数据库乐观锁
        这种方式适合在更新的场景中。
     3、业务层分布式锁
        如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数据处理，我们就可以
        加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。
4.3 各种唯一约束
      1、数据库唯一约束
        插入数据，应该按照唯一索引进行插入，比如:订单号，相同的订单号就不能有两条记录插入。
        我们在数据库层面防止重复。
        这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。
        但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。
        如果是分库分表场景下，路由规则要保证相同请求下，落在同一个数据库和同一表中，要不然数据库约束就不起
        效果了，因为是不同的数据库和表主键不想关
       2、redis set防重
       很多数据需要处理，只能被处理一次，比如我们可以计算数据的MD5将其放入redis的set，每次处理数据，先看
       md5是否存在，存在就不处理。
4.4 防重表
       使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中，
       这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。注意，去重表和业务表应该在
       同一数据库中，这样就保证了在同一个事务，即使业务操作失败，也会把去重表的数据回滚。这个很好的保证了数
       据一致性。
4.5 全局请求唯一id
        调用接口时，生成一个唯一id,redis将数据保存到集合中(去重)，存在即处理过，可以使用nginx设置每一个
        请求的唯一id proxy_set_header X-Request-Id $request_id;
